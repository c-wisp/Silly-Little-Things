#!/usr/bin/env bash
#diffmaker v0.1.0
#depends on bash v3.0+, du, cat, and hexdump

#TODO: collapse folder deletions during -r
#Add -rV option (verbose, dont collapse folder deletions)
#Add --no-dump (skips hexdump, resulting in no minor image changes being shown (although is much faster to run))
#Make -c the default (why would it ever not be used????)
#Add option to show output in terminal

#DONE: Write, Compare, Help, Version
#PARTIAL: Recursive (will also need to make minor changes to Compare to fix)
#Unstarted: Verbose, No Dump, Compare As Default

###ARGBASH SECTION ARGBASH SECTION###
# ARG_OPTIONAL_BOOLEAN([compare],[c],[Compare files between directories])
# ARG_OPTIONAL_BOOLEAN([write],[w],[Write an output file])
# ARG_OPTIONAL_BOOLEAN([recursive],[r],[Apply script recursively to input directories])
# ARG_LEFTOVERS([])
# ARG_VERSION()
# ARG_HELP()
#
### START OF CODE GENERATED BY Argbash v2.9.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate


die() {
	local _ret="${2:-1}"
	test "${_PRINT_ERR:-no}" = yes && show_help >&2
	echo "$1" >&2
	exit "${_ret}"
}

show_help() {
cat << EOF
diffmaker v0.1.0
Usage : ./diffmaker [ARGS] <INPUT DIR1> <INPUT DIR2> <OUTPUT DIR>

	-h , --help		Show help
	-c , --compare		Compare files between direrctories
	-w , --write		Write diff to output directory
	-r , --recursive	Apply recursively
	-v , --version		Show version
	<INPUT DIR1>		Directory to compare with
	<INPUT DIR2>		Directory to compare against
	<OUTPUT DIR>		Directory to place output file

Example : ./diffmaker -cwr ~/Docs/Proj1 ~/Docs/Proj1-backup ~/Docs/Proj1-diff.txt
EOF
}

begins_with_short_option() {
	local first_option all_short_options='cwrioh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

### Importante' vars ###
_arg_compare="off"
_arg_write="off"
_arg_recursive="off"
_arg_leftovers=()

#sets flags to use later, kept separate cuz this is long ass
parse_commandline() {
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-c|--no-compare|--compare)
				_arg_compare="on"
				test "${1:0:5}" = "--no-" && _arg_compare="off"
				;;
			-c*)
				_arg_compare="on"
				_next="${_key##-c}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-c" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-w|--no-write|--write)
				_arg_write="on"
				test "${1:0:5}" = "--no-" && _arg_write="off"
				;;
			-w*)
				_arg_write="on"
				_next="${_key##-w}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-w" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-r|--no-recursive|--recursive)
				_arg_recursive="on"
				test "${1:0:5}" = "--no-" && _arg_recursive="off"
				;;
			-r*)
				_arg_recursive="on"
				_next="${_key##-r}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-r" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-h|--help)
				show_help && exit 0
				;;
			-h*)
				show_help && exit 0
				;;
			-v|--version)
				printf "Diffmaker.sh v0.1.0\n" && exit 0
				;;
			-v*)
				printf "Diffmaker.sh v0.1.0\n" && exit 0
				;;
			-*)
				_PRINT_ERR=yes die "FATAL ERROR: Got an unexpected argument '$1'" 1
				;;
			*)
				_arg_leftovers+=("$_key")
				;;
		esac
		shift
	done
}

parse_commandline "$@"


###ARGBASH END ARGBASH END###


append_files() {
	if [ $f -eq 0 ]; then input1+=("${filelist[@]}"); else input2+=("${filelist[@]}"); fi
}

loop_subdir() {
	current="$1"
	if [ "$_arg_recursive" == "on" ]
		then for subdir in "${current[@]}"
			do filelist=("$subdir"/*.*)
			#append any files found along the way
			if [[ ${filelist[0]} != "$subdir/*.*" ]]; then append_files; fi
			
			#check for folders
			folderlist=()
			temp=("$subdir"/*)
			if [ "${temp[0]}" = "$subdir/*" ]; #append empty ones
				then if [ $f -eq 0 ]; then input1+=("$subdir"); else input2+=("$subdir"); fi
			return; fi
			
			#deeper
			for fldr in "${temp[@]}"; do if [ -d "$fldr" ]; then folderlist+=("$fldr"); fi; done; unset fldr
			for sbfldr in "${folderlist[@]}"; do loop_subdir "$sbfldr"; done #endless?
		done; unset sbfldr
	elif [ $f -eq 0 ]; then input1+=("${folderlist[@]}");
	else input2+=("${folderlist[@]}"); fi
}

#returns true/false if given array has a value
array_has() { #arg1=array name, arg2=item
	local -n array="$1"
	local value="$2"
	[[ "${array[*]}" == *"$value"* ]] && echo "true" || echo "false"
}

get_filesize() {
	local filepath="$1"
	local size
	size=$(du -bs "$filepath")
	size="${size%"	$filepath"}"; echo "$size"
}

### main logic ###


#cull nonexistant dirs
directories=()
for iod in "${_arg_leftovers[@]}"
	do iod="${iod/'~'/$HOME}" #"" compat (can have spaces in dir names)
	if [ -d "$iod" ]; then directories+=("$iod")
	else printf 'ERROR: Directory "'"%s"'" was not found\n' "$iod"; fi
done; unset iod

#prevent execution w/ too few i/o
if [ "$_arg_write" == "on" ] && (( "${#directories[@]}" < 3 ))
	then printf "FATAL ERROR: No output directory found\n"; exit 1; fi
if [ "$_arg_compare" == "on" ] && (( "${#directories[@]}" < 2 ))
	then printf "FATAL ERROR: Not enough input directories, got %d\n" "${#directories[@]}"; exit 1; fi
if [ "$_arg_recursive" == "on" ] && (( "${#directories[@]}" == 0 ))
	then printf "FATAL ERROR: No input directory found\n"; exit 1; fi

#read input dirs
if [ "$_arg_compare" = "on" ]
	then input1=()
	input2=()
	
	for ((f=0; f<2; f++)) #loop through first 2 dirs
		do filelist=("${directories[$f]}"/*.*) #get list
		if [[ ${filelist[0]} = "${directories[$f]}/*.*" ]]; then continue; fi #skip empty folders
		
		append_files
		
		#find subdirs
		folderlist=()
		temp=("${directories[$f]}"/*)
		for fldr in "${temp[@]}"; do if [ -d "$fldr" ]; then folderlist+=("$fldr"); fi; done
		
		if [ "$_arg_recursive" == "on" ];
			then for i in "${folderlist[@]}" #loop through each subfolder (and their ones too)
				do loop_subdir "$i"; done; unset i
		#autoappend extra folders (not going deeper today)
		elif [ $f -eq 0 ]; then input1+=("${folderlist[@]}");
		else input2+=("${folderlist[@]}"); fi
	
	#trim dir labels to make comparison easier (just use "${directory[0]}/${input1[INDEX]}")
	temp=()
	if [ $f -eq 0 ]
		then for i in "${input1[@]}"
			do i="${i/"${directories[0]}/"/""}"
			temp+=("$i")
		done; input1=("${temp[@]}"); unset i; unset temp
	else for i in "${input2[@]}"
			do i="${i/"${directories[1]}/"/""}"
			temp+=("$i")
		done; input2=("${temp[@]}"); unset i; unset temp
	fi
	done; unset f
	
	#actually compare inputs
	diff_str='::: Diffmaker v0.1.0 :::  \n::: Output from "'"$0 $*"'" :::\n' #header to file on export, easier to set now
	text_formats=("txt" "rtf" "bash" "sh" "c" "rb" "py" "js" "rs" "gd" "tscn" "import" "cfg" "tres" "godot" "json" "md")
	for file in "${input1[@]}" #check for new files
		do check=$(array_has "input2" "$file")
		if [ "$check" == "true" ]; then unset check
			#need to use hexdump to read the files if not utf-8 encoded
			if [ ! -d "${directories[0]}/$file" ]
				then for t in "${text_formats[@]}"
					do if [[ "$file" == *".$t" ]]; then check="true"; fi; done
			fi
			
			if [ "$check" == "true" ] #is a text format
				then if [ "$(<"""${directories[0]}/$file""")" != "$(<"""${directories[1]}/$file""")" ]
					then sizei1=$(get_filesize "${directories[0]}/$file"); sizei2=$(get_filesize "${directories[1]}/$file"); fi
			elif [ -d "${directories[0]}/$file" ]
				then sizei1=$(du -bs "${directories[0]}/$file"); sizei1="${sizei1%"	${directories[0]}/$file"}"
				sizei2=$(du -bs "${directories[1]}/$file"); sizei2="${sizei2%"	${directories[1]}/$file"}"
				if (( "$sizei1" == "$sizei2" )); then continue; fi
			#non text (exe, png, obj, yknow)
			elif [ "$(hexdump """${directories[0]}/$file""")" != "$(hexdump """${directories[1]}/$file""")" ]
				then sizei1=$(get_filesize "${directories[0]}/$file"); sizei2=$(get_filesize "${directories[1]}/$file")
			else continue; fi
			
			if (( "$sizei1" > "$sizei2" )); then diff_str+="+$(( sizei1 - sizei2 ))B : $file\n"
				else diff_str+="$(( sizei1 - sizei2 ))B : $file\n"; fi
		
		else path="${directories[0]}/$file"; size=$(du -bs "$path"); size="${size%"	$path"}"
			diff_str+="+${size}B : $file\n"
		fi
	done; unset file; unset text_formats; unset sizei1; unset sizei2; unset size; unset path
	
	for file in "${input2[@]}" #check for deleted files
		do check=$(array_has "input1" "$file")
		if [ "$check" == "false" ];
			then path="${directories[1]}/$file"; size=$(du -bs "$path"); size="${size%"	$path"}"
			#annotate deleted files so that users know that they are *actually* gone
			diff_str+="-${size}B (DEL) : $file\n"
		fi; unset size; unset path
	done; unset file
fi

if [ "$_arg_write" == "on" ];
	then filename=""
	outputfiles=("${directories[2]}"/diff*.out)
	if [ "$(array_has """outputfiles""" """diff.out""")" == "false" ]; then filename="diff.out"
	else declare -i i=1
		while [ "$filename" == "" ]
			do check="false"
			for f in "${outputfiles[@]}"
				do if [ "$f" == "${directories[2]}/diff($i).out" ]; then i+=1; check="true"; fi; done
			if [ "$check" == "false" ]; then filename="diff($i).out"; fi
		done
	fi
	echo -e "$diff_str" > "${directories[2]}/$filename"
fi

printf '::: output :::\n%b' "$diff_str"